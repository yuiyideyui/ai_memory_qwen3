<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>AI å±‹å­ç®¡ç†ç³»ç»Ÿ</title>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        /* -------------------------------------- */
        /* æˆ¿é—´å¸ƒå±€å®¹å™¨æ ·å¼ */
        /* -------------------------------------- */
        #room-container {
            margin: 20px 0;
            position: relative;
            /* å°ºå¯¸å°†åœ¨ JS ä¸­æ ¹æ® roomData åŠ¨æ€è®¾ç½® */
            width: 800px;
            height: 600px;
        }

        #room {
            position: relative;
            /* ç§»é™¤åŸæœ‰çš„ç½‘æ ¼èƒŒæ™¯å’Œè¾¹æ¡†ï¼Œç”± Canvas æ¥ç®¡æ¸²æŸ“ */
            cursor: crosshair;
            width: 800px;
            height: 600px;
            z-index: 1;
        }

        /* æ–°å¢ Canvas æ ·å¼ */
        #roomCanvas {
            border: 2px solid #555;
            background-color: #fcfcfc;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* ç¡®ä¿åœ¨è§’è‰²ä¹‹ä¸‹ */
        }
        
        /* -------------------------------------- */
        /* è§’è‰²æ ·å¼ */
        /* -------------------------------------- */
        .role {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: move;
            transition: transform 0.1s;
            z-index: 10;
        }

        .role.user {
            background-color: #ADD8E6;
            border: 3px solid #4682B4;
        }

        .role.ai {
            background-color: #F0E68C;
            border: 3px solid #DAA520;
        }

        /* -------------------------------------- */
        /* æ¶ˆæ¯å’Œæ§åˆ¶é¢æ¿æ ·å¼ */
        /* -------------------------------------- */
        .controls {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            background: #f1f1f1;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-panel {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            background: #fff;
        }

        #chatLog {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 10px;
            background: #fafafa;
        }

        .message {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .user-message {
            color: #337ab7;
        }

        .ai-message {
            color: #5cb85c;
        }
        
        /* è§’è‰²ä¿¡æ¯æ¡†æ ·å¼ */
        .role-info {
            position: absolute;
            background-color: white;
            border: 1px solid #333;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€åˆ°ä¸‹é¢çš„è§’è‰² */
            white-space: nowrap;
        }
    </style>
</head>

<body>

    <h1>ğŸ  AI å±‹å­ç®¡ç†ç³»ç»Ÿ</h1>
    
    <p>å½“å‰åœ°å›¾ï¼š**ç¢°æ’ä¿®å¤ç‰ˆå•å±‚ä½å®…å¹³é¢å›¾**ã€‚è¯·ä½¿ç”¨ **W A S D** é”®æˆ–æ‹–æ‹½äººç‰© (ğŸ‘¤) ç§»åŠ¨ã€‚</p>

    <div id="room-container">
        <canvas id="roomCanvas" width="800" height="600"></canvas>
        <div id="room">
            </div>
        <div id="roleInfo" class="role-info" style="display: none;"></div>
    </div>

    <div class="controls">
        <label for="roomName">æˆ¿é—´:</label>
        <input type="text" id="roomName" value="main" placeholder="æˆ¿é—´åç§°">
        <button onclick="loadRoom()">åŠ è½½æˆ¿é—´</button>
        <button onclick="clearRoom()">æ¸…ç©ºæˆ¿é—´</button>
        <button id="addRoleButton" onclick="addRole()" disabled>æ–°å¢ AI è§’è‰²</button>
    </div>

    <div class="controls">
        <label>ç”¨æˆ·ä½ç½® (ä¸­å¿ƒ):</label>
        <span id="userPosition">(N/A)</span>
        <button id="updatePositionButton" onclick="updateRolePosition('user')" disabled>æ›´æ–°ä½ç½®</button>
        <button id="removeUserButton" onclick="removeRole('user')" disabled>ç§»é™¤ç”¨æˆ·</button>
    </div>
    
    <div class="controls">
        <label>è™šæ‹Ÿæ—¶é—´:</label>
        <span id="acceleratedTime">æ­£åœ¨åŠ è½½...</span>
        <button onclick="toggleTimeAcceleration()">åŠ é€Ÿ/æš‚åœ</button>
    </div>

    <div class="chat-panel">
        <h2>èŠå¤©ä¸æŒ‡ä»¤</h2>
        <div id="chatLog"></div>
        <div style="display: flex; gap: 10px;">
            <input type="text" id="chatMessage" placeholder="å‘ AI è§’è‰²å‘é€æŒ‡ä»¤æˆ–å¯¹è¯" style="flex-grow: 1;">
            <button onclick="sendMessage()">å‘é€</button>
        </div>
        <p>Tip: å°è¯•å‘é€â€œç°åœ¨å‡ ç‚¹â€æ¥è·å–è™šæ‹Ÿæ—¶é—´ï¼Œæˆ–å‘é€â€œä½ åœ¨åšä»€ä¹ˆï¼Ÿâ€æ¥æŸ¥è¯¢è§’è‰²çš„å½“å‰æ´»åŠ¨ã€‚</p>
    </div>

    <script>
        const socket = io();
        let currentRoomName = "main";
        let userPosition = null;
        let roomDimensions = { width: 800, height: 600 };

        // âŒ æ–°å¢å…¨å±€å˜é‡
        const canvas = document.getElementById('roomCanvas');
        const ctx = canvas.getContext('2d');
        let roomData = null; // ç”¨äºå­˜å‚¨ä»æœåŠ¡å™¨è·å–çš„å®Œæ•´æˆ¿é—´æ•°æ®
        const MOVE_SPEED = 3;
        const roleSize = 60; // HTML è§’è‰² div çš„å°ºå¯¸

        // ------------------------------------
        // Socket.IO æ¶ˆæ¯å¤„ç† (ä¿æŒåŸæœ‰åŠŸèƒ½)
        // ------------------------------------

        socket.on('connect', () => {
            console.log('å·²è¿æ¥åˆ°æœåŠ¡å™¨');
            loadRoom(); // è¿æ¥åé»˜è®¤åŠ è½½æˆ¿é—´
        });

        socket.on('room_update', (data) => {
            console.log('æˆ¿é—´æ•°æ®æ›´æ–°:', data);
            
            // âŒ æ›´æ–°å…¨å±€ roomData å¹¶é‡æ–°ç»˜åˆ¶åœ°å›¾
            roomData = data; 
            drawRoomMap(); 

            // æ›´æ–° roomDimensions å¹¶è®¾ç½®å®¹å™¨å¤§å°
            roomDimensions = { width: data.width, height: data.height };
            document.getElementById("room").style.width = roomDimensions.width + 'px';
            document.getElementById("room").style.height = roomDimensions.height + 'px';
            canvas.width = roomDimensions.width;
            canvas.height = roomDimensions.height;
            document.getElementById("room-container").style.width = roomDimensions.width + 'px';
            document.getElementById("room-container").style.height = roomDimensions.height + 'px';


            // æ¸…ç†å¹¶é‡æ–°æ¸²æŸ“è§’è‰²
            const roomDiv = document.getElementById("room");
            const existingRoles = Array.from(roomDiv.querySelectorAll('.role'));
            const existingRoleNames = existingRoles.map(el => el.dataset.roleName);
            const newRoleNames = data.roles.map(r => r.name);

            // ç§»é™¤ä¸å†å­˜åœ¨çš„è§’è‰²
            existingRoles.filter(el => !newRoleNames.includes(el.dataset.roleName))
                .forEach(el => el.parentElement.remove());

            // æ·»åŠ æˆ–æ›´æ–°å­˜åœ¨çš„è§’è‰²
            data.roles.forEach(role => {
                if (role.name.toLowerCase() === 'user') {
                    // æ›´æ–°ç”¨æˆ·è§’è‰²ä½ç½®å’ŒçŠ¶æ€
                    userPosition = { x: role.x, y: role.y };
                    document.getElementById("userPosition").innerText = 
                        `(${userPosition.x}, ${userPosition.y}) å·²è®¾ç½®`;
                    updateUserButtons(true);
                    updateUserRoleDisplay(role); // ç¡®ä¿ç”¨æˆ·å›¾æ ‡æ˜¾ç¤º
                } else {
                    addRoleToRoom(role);
                }
            });
        });
        
        socket.on('time_update', (data) => {
            document.getElementById('acceleratedTime').innerText = 
                `${data.formatted_time} (å€é€Ÿ: ${data.multiplier}x)`;
        });

        socket.on('chat_message', (data) => {
            appendMessage(data.role, data.message);
        });
        
        socket.on('role_activity', (data) => {
            const roleElement = document.querySelector(`.role[data-role-name="${data.role_name}"]`);
            if (roleElement) {
                // ä»…æ›´æ–°è§’è‰²çš„çŠ¶æ€æè¿°
                roleElement.dataset.activity = data.activity;
                
                // ç¡®ä¿ç”¨æˆ·ç‚¹å‡»æ—¶ä¿¡æ¯èƒ½è¢«å±•ç¤º
                if (document.getElementById("roleInfo").dataset.roleName === data.role_name) {
                     showRoleInfo(roleElement);
                }
            }
        });


        // ------------------------------------
        // æˆ¿é—´åœ°å›¾æ¸²æŸ“é€»è¾‘ (ä» room.html å¤åˆ¶/ä¿®æ”¹)
        // ------------------------------------
        
        function drawFurniture(item, ctx) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            if (item.type === 'bed') {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.fillStyle = '#555';
                ctx.fillRect(item.x, item.y, item.width, 10);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(item.x + 10, item.y + 15, item.width / 4, 20);
                ctx.fillRect(item.x + item.width - 10 - item.width / 4, item.y + 15, item.width / 4, 20);
            } else if (item.type === 'sofa') {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.fillStyle = '#777';
                ctx.fillRect(item.x, item.y, item.width, 10);
                ctx.strokeRect(item.x, item.y, item.width, item.height);
            } else if (item.type === 'table') {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#4682B4';
                ctx.lineWidth = 2;
                ctx.strokeRect(item.x + 10, item.y + 10, item.width - 20, item.height - 20);
            } else if (item.type === 'counter' || item.type === 'cabinet' || item.type === 'fridge' || item.type === 'closet') {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#777';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(item.x + 3, item.y + 3);
                ctx.lineTo(item.x + item.width - 3, item.y + 3);
                ctx.moveTo(item.x + 3, item.y + item.height - 3);
                ctx.lineTo(item.x + item.width - 3, item.y + item.height - 3);
                ctx.stroke();
            } else if (item.type === 'shower') {
                ctx.strokeStyle = '#1E90FF';
                ctx.lineWidth = 2;
                ctx.strokeRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#ADD8E6';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(item.x, item.y);
                ctx.lineTo(item.x + item.width, item.y + item.height);
                ctx.stroke();
            } else if (item.type === 'toilet') {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(item.x, item.y, item.width, item.height);
                ctx.beginPath();
                ctx.arc(item.x + item.width / 2, item.y + item.height / 2, item.width / 4, 0, 2 * Math.PI);
                ctx.stroke();
            } else if (item.type === 'sink') {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(item.x, item.y, item.width, item.height);
                ctx.beginPath();
                ctx.arc(item.x + item.width / 2, item.y + item.height / 2, item.width / 4, 0, Math.PI, true);
                ctx.stroke();
            } else {
                ctx.fillStyle = item.color || '#D3D3D3';
                ctx.fillRect(item.x, item.y, item.width, item.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(item.x, item.y, item.width, item.height);
            }
        }

        function drawRoomMap() {
            if (!roomData || !roomData.layout) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶åŒºåŸŸ (Area)
            roomData.layout.areas.forEach(area => {
                ctx.fillStyle = area.color;
                ctx.fillRect(area.x, area.y, area.width, area.height);
                
                ctx.fillStyle = "#333";
                ctx.font = "16px Arial";
                ctx.textAlign = "center";
                ctx.fillText(area.name, area.x + area.width / 2, area.y + 20);
            });

            // ç»˜åˆ¶å®¶å…· (Furniture)
            roomData.layout.furniture.forEach(item => {
                drawFurniture(item, ctx);
            });

            // ç»˜åˆ¶å¢™å£ (Wall)
            roomData.layout.walls.forEach(wall => {
                const lineStart = { x: wall.x1, y: wall.y1 };
                const lineEnd = { x: wall.x2, y: wall.y2 };
                
                ctx.strokeStyle = wall.isOuter ? '#333' : '#666';
                ctx.lineWidth = wall.thickness;
                ctx.beginPath();
                ctx.moveTo(lineStart.x, lineStart.y);
                ctx.lineTo(lineEnd.x, lineEnd.y);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
            });

            // ç»˜åˆ¶é—¨ (Door)
            roomData.layout.doors.forEach(door => {
                // é—¨æ´éƒ¨åˆ†ç”¨èƒŒæ™¯è‰²å¡«å……ä»¥æ˜¾ç¤ºâ€œç¼ºå£â€
                ctx.fillStyle = '#fcfcfc'; // åŒ¹é… canvas èƒŒæ™¯è‰²
                if (door.direction === 'vertical') {
                    const x = door.x;
                    ctx.fillRect(x - door.thickness / 2, door.y, door.thickness, door.width);
                } else {
                    const y = door.y;
                    ctx.fillRect(door.x, y - door.thickness / 2, door.width, door.thickness);
                }

                // ç»˜åˆ¶é—¨æœ¬èº«ï¼ˆç®€åŒ–ï¼‰
                ctx.fillStyle = '#A0522D';
                if (door.direction === 'vertical') {
                    const x = door.x;
                    ctx.fillRect(x - door.thickness / 2, door.y + door.width / 2 - 5, door.thickness, 10);
                } else {
                    const y = door.y;
                    ctx.fillRect(door.x + door.width / 2 - 5, y - door.thickness / 2, 10, door.thickness);
                }
            });

            // ç»˜åˆ¶çª—æˆ· (Window)
            roomData.layout.windows.forEach(window => {
                const lineY = window.y;
                const halfThickness = window.thickness / 2;
                
                ctx.strokeStyle = '#4682B4';
                ctx.lineWidth = window.thickness;
                ctx.beginPath();
                ctx.moveTo(window.x, lineY);
                ctx.lineTo(window.x + window.width, lineY);
                ctx.stroke();
                
                ctx.strokeStyle = '#ADD8E6';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(window.x, lineY - halfThickness * 0.5);
                ctx.lineTo(window.x + window.width, lineY - halfThickness * 0.5);
                ctx.moveTo(window.x, lineY + halfThickness * 0.5);
                ctx.lineTo(window.x + window.width, lineY + halfThickness * 0.5);
                ctx.stroke();
            });
        }

        // ------------------------------------
        // ç¢°æ’æ£€æµ‹å‡½æ•° (ä» room.html å¤åˆ¶/ä¿®æ”¹)
        // ------------------------------------

        function checkAABBCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        function checkCollision(x, y) {
            if (!roomData || !roomData.layout) return false;

            // äººç‰©çŸ©å½¢ (x, y ä¸ºä¸­å¿ƒç‚¹, roleSize=60)
            const personRect = {
                x: x - roleSize / 2,
                y: y - roleSize / 2,
                width: roleSize,
                height: roleSize
            };

            // 1. æ£€æŸ¥å¢™å£ç¢°æ’
            for (const wall of roomData.layout.walls) {
                let wallRect;
                const thickness = wall.thickness;

                if (wall.x1 === wall.x2) { // å‚ç›´å¢™
                    const wallX = wall.x1 - thickness / 2;
                    const wallY = Math.min(wall.y1, wall.y2);
                    const wallHeight = Math.abs(wall.y1 - wall.y2);
                    wallRect = { x: wallX, y: wallY, width: thickness, height: wallHeight };
                } else { // æ°´å¹³å¢™
                    const wallX = Math.min(wall.x1, wall.x2);
                    const wallY = wall.y1 - thickness / 2;
                    const wallWidth = Math.abs(wall.x1 - wall.x2);
                    wallRect = { x: wallX, y: wallY, width: wallWidth, height: thickness };
                }

                if (checkAABBCollision(personRect, wallRect)) {
                    // 2. æ£€æŸ¥æ˜¯å¦ç©¿è¿‡é—¨ (ä¿®æ­£ç¢°æ’é€»è¾‘)
                    let isCollidingWithDoor = false;
                    // é—¨æ´åˆ¤å®šåšåº¦æ‰©å¤§åˆ°ç•¥å¤§äºäººç‰©å°ºå¯¸
                    const DOOR_TOLERANCE_FOR_CHECK = roleSize; 

                    for (const door of roomData.layout.doors) {
                        let doorRect;
                        if (door.direction === 'vertical') {
                            const doorX = door.x - DOOR_TOLERANCE_FOR_CHECK / 2;
                            doorRect = { x: doorX, y: door.y, width: DOOR_TOLERANCE_FOR_CHECK, height: door.width };
                        } else {
                            const doorY = door.y - DOOR_TOLERANCE_FOR_CHECK / 2;
                            doorRect = { x: door.x, y: doorY, width: door.width, height: DOOR_TOLERANCE_FOR_CHECK };
                        }
                        
                        // åªéœ€è¦æ£€æŸ¥æ˜¯å¦ä½äºé—¨çš„å®½åº¦å’Œåšåº¦çš„**ä¸­å¤®**ï¼Œå› ä¸ºäººç‰©ä¸­å¿ƒç§»åŠ¨æ—¶ï¼Œåªè¦åœ¨é—¨æ´å†…å°±ä¸ç®—ç¢°æ’
                        if (checkAABBCollision(personRect, doorRect)) {
                            isCollidingWithDoor = true;
                            break;
                        }
                    }
                    
                    if (!isCollidingWithDoor) {
                        return true; // æ’å¢™ä¸”æ²¡æ’åˆ°é—¨ï¼Œåˆ¤å®šä¸ºç¢°æ’
                    }
                }
            }

            // 3. æ£€æŸ¥å®¶å…·ç¢°æ’ 
            for (const item of roomData.layout.furniture) {
                const furnitureRect = { x: item.x, y: item.y, width: item.width, height: item.height };
                if (checkAABBCollision(personRect, furnitureRect)) {
                    return true;
                }
            }
            
            // 4. è¾¹ç•Œç¢°æ’ (50, 50) - (750, 550) å‡è®¾æ˜¯å¤–å¢™çš„ä¸­å¿ƒçº¿
            const personHalfSize = roleSize / 2;
            if (x < 50 + personHalfSize || x > 750 - personHalfSize || y < 50 + personHalfSize || y > 550 - personHalfSize) {
                return true;
            }
            
            return false;
        }

        // ------------------------------------
        // é”®ç›˜æŒç»­ç§»åŠ¨é€»è¾‘ (gameLoop)
        // ------------------------------------
        const DEBOUNCE_DELAY = 100;
        let debounceTimer;
        
        // ç›‘å¬ WASD é”®
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key.toUpperCase()] = true; });
        document.addEventListener('keyup', (e) => { keys[e.key.toUpperCase()] = false; });

        function gameLoop() {
            const userRoleElementContainer = document.querySelector('.role.user').parentElement;
            if (!userRoleElementContainer || !userPosition) {
                requestAnimationFrame(gameLoop);
                return;
            }

            let nextX = userPosition.x;
            let nextY = userPosition.y;
            let moved = false;

            if (keys['W']) { nextY -= MOVE_SPEED; moved = true; }
            if (keys['S']) { nextY += MOVE_SPEED; moved = true; }
            if (keys['A']) { nextX -= MOVE_SPEED; moved = true; }
            if (keys['D']) { nextX += MOVE_SPEED; moved = true; }

            if (moved) {
                const targetX = nextX;
                const targetY = nextY;
                let finalX = userPosition.x;
                let finalY = userPosition.y;

                // å°è¯•ç‹¬ç«‹ç§»åŠ¨ X è½´å’Œ Y è½´ï¼Œå¤„ç†æ–œå‘ç¢°æ’
                if (!checkCollision(targetX, userPosition.y)) { finalX = targetX; }
                if (!checkCollision(userPosition.x, targetY)) { finalY = targetY; }

                if (finalX !== userPosition.x || finalY !== userPosition.y) {
                    userPosition.x = finalX;
                    userPosition.y = finalY;
                    
                    // æ›´æ–° HTML DIV ä½ç½® (ä¸­å¿ƒç‚¹åæ ‡è½¬ä¸ºå·¦ä¸Šè§’åæ ‡: -30)
                    userRoleElementContainer.style.left = (finalX - 30) + 'px';
                    userRoleElementContainer.style.top = (finalY - 30) + 'px';
                    
                    document.getElementById("userPosition").innerText = 
                        `(${Math.round(finalX)}, ${Math.round(finalY)}) å·²è®¾ç½®`;
                        
                    // é˜²æŠ–æ›´æ–°ä½ç½®åˆ°æœåŠ¡å™¨
                    debounceUpdateRolePosition("user", Math.round(finalX), Math.round(finalY)); 
                }
            }

            requestAnimationFrame(gameLoop);
        }
        gameLoop(); // å¯åŠ¨æ¸¸æˆå¾ªç¯


        // ------------------------------------
        // åŸºç¡€åŠŸèƒ½å‡½æ•° (ä¿æŒåŸæœ‰åŠŸèƒ½ï¼Œéƒ¨åˆ†ä¿®æ”¹)
        // ------------------------------------
        
        function updateUserButtons(enabled) {
            document.getElementById("updatePositionButton").disabled = !enabled;
            document.getElementById("removeUserButton").disabled = !enabled;
            document.getElementById("addRoleButton").disabled = !enabled;
        }

        function appendMessage(role, message) {
            const log = document.getElementById('chatLog');
            const msgDiv = document.createElement('div');
            const roleClass = role === 'user' ? 'user-message' : 'ai-message';
            msgDiv.className = `message ${roleClass}`;
            msgDiv.innerHTML = `<strong>${role}:</strong> ${message}`;
            log.appendChild(msgDiv);
            log.scrollTop = log.scrollHeight;
        }

        function showRoleInfo(element) {
            const infoBox = document.getElementById("roleInfo");
            const roleName = element.dataset.roleName;
            const activity = element.dataset.activity || "ç©ºé—²ä¸­";
            const position = element.parentElement.style;

            infoBox.innerHTML = `<strong>${roleName}</strong><br>æ´»åŠ¨: ${activity}`;
            infoBox.style.left = (parseInt(position.left) + roleSize + 10) + 'px';
            infoBox.style.top = position.top;
            infoBox.style.display = "block";
            infoBox.dataset.roleName = roleName;
        }

        function makeDraggable(element, role) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;

            element.addEventListener('mousedown', startDrag);
            element.addEventListener('touchstart', startDrag, { passive: false });

            function startDrag(e) {
                e.preventDefault();
                if (e.type === 'mousedown' && e.button !== 0) return; 

                const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
                startX = clientX;
                startY = clientY;
                startLeft = parseInt(element.style.left) || 0;
                startTop = parseInt(element.style.top) || 0;

                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('touchend', stopDrag);

                element.style.zIndex = '1000';
                element.style.cursor = 'grabbing';
                isDragging = false; 
            }

            function drag(e) {
                e.preventDefault();
                const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
                
                const dx = clientX - startX;
                const dy = clientY - startY;

                if (!isDragging && (Math.abs(dx) < 3 && Math.abs(dy) < 3)) { return; }
                isDragging = true; 

                document.getElementById("roleInfo").style.display = "none";

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                
                const newCenterX = Math.round(newLeft + roleSize / 2);
                const newCenterY = Math.round(newTop + roleSize / 2);
                
                // âŒ ç¢°æ’æ£€æµ‹
                if (roomData && checkCollision(newCenterX, newCenterY)) {
                    // å¦‚æœå‘ç”Ÿç¢°æ’ï¼Œåˆ™ä¸æ›´æ–°ä½ç½®
                    return;
                }

                // è¾¹ç•Œæ£€æŸ¥ (ä½¿ç”¨ left/top åæ ‡)
                newLeft = Math.max(0, Math.min(newLeft, roomDimensions.width - roleSize));
                newTop = Math.max(0, Math.min(newTop, roomDimensions.height - roleSize)); 

                // æ›´æ–°ä½ç½®
                element.style.left = newLeft + 'px';
                element.style.top = newTop + 'px';

                if (role.name.toLowerCase() === "user") {
                    userPosition = { x: Math.round(newLeft + roleSize / 2), y: Math.round(newTop + roleSize / 2) };
                    document.getElementById("userPosition").innerText = 
                        `(${userPosition.x}, ${userPosition.y})`;
                }
            }

            function stopDrag(e) {
                e.preventDefault();
                // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('touchend', stopDrag);

                element.style.cursor = 'move';
                element.style.zIndex = '10';

                if (isDragging) {
                    const currentLeft = parseInt(element.style.left);
                    const currentTop = parseInt(element.style.top);
                    debounceUpdateRolePosition(role.name, Math.round(currentLeft + roleSize / 2), Math.round(currentTop + roleSize / 2));
                }
                isDragging = false;
            }
        }
        
        function createRoleElement(role) {
            const roleDivContainer = document.createElement('div');
            roleDivContainer.className = 'role-container';
            roleDivContainer.style.position = 'absolute';
            // å°†ä¸­å¿ƒåæ ‡è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ (ä¸­å¿ƒç‚¹ - 30)
            roleDivContainer.style.left = (role.x - roleSize / 2) + 'px';
            roleDivContainer.style.top = (role.y - roleSize / 2) + 'px';

            const roleDiv = document.createElement('div');
            roleDiv.className = `role ${role.type} ${role.name.toLowerCase()}`;
            roleDiv.dataset.roleName = role.name;
            roleDiv.dataset.activity = role.activity || 'ç©ºé—²ä¸­'; // åˆå§‹æ´»åŠ¨çŠ¶æ€
            roleDiv.innerHTML = role.avatar || 'â“';
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶æ˜¾ç¤ºä¿¡æ¯
            roleDiv.addEventListener('click', (e) => {
                e.stopPropagation();
                showRoleInfo(roleDiv);
            });

            roleDivContainer.appendChild(roleDiv);
            
            return { container: roleDivContainer, element: roleDiv };
        }

        function addRoleToRoom(role) {
            const existingContainer = document.querySelector(`.role[data-role-name="${role.name}"]`)?.parentElement;
            
            if (existingContainer) {
                // å¦‚æœå·²å­˜åœ¨ï¼Œä»…æ›´æ–°ä½ç½®å’Œä¿¡æ¯
                existingContainer.style.left = (role.x - roleSize / 2) + 'px';
                existingContainer.style.top = (role.y - roleSize / 2) + 'px';
                existingContainer.querySelector('.role').dataset.activity = role.activity || 'ç©ºé—²ä¸­';
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°è§’è‰²
                const { container, element } = createRoleElement(role);
                document.getElementById("room").appendChild(container);
                makeDraggable(container, role);
            }
        }
        
        function updateUserRoleDisplay(role) {
             const existingContainer = document.querySelector(`.role.user`)?.parentElement;
             
             if (existingContainer) {
                existingContainer.style.left = (role.x - roleSize / 2) + 'px';
                existingContainer.style.top = (role.y - roleSize / 2) + 'px';
             } else {
                 addUserToRoom();
             }
        }

        function addUserToRoom() {
            if (!userPosition) return;
            const existing = document.querySelector('.role.user');
            
            // ç¡®ä¿åªæœ‰ä¸€ä¸ªç”¨æˆ·è§’è‰²
            if (existing) {
                const container = existing.parentElement;
                container.style.left = (userPosition.x - roleSize / 2) + 'px';
                container.style.top = (userPosition.y - roleSize / 2) + 'px';
                return;
            }

            const role = { name: "user", type: "person", x: userPosition.x, y: userPosition.y, avatar: "ğŸ‘¤" };
            const { container, element } = createRoleElement(role);
            document.getElementById("room").appendChild(container);
            makeDraggable(container, role);
        }
        
        function debounceUpdateRolePosition(role_name, x, y) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                updateRolePosition(role_name, x, y);
            }, DEBOUNCE_DELAY);
        }
        
        // ------------------------------------
        // API è°ƒç”¨å‡½æ•°
        // ------------------------------------
        
        async function loadRoom() {
            currentRoomName = document.getElementById("roomName").value || "main";
            try {
                const response = await fetch(`/api/room/${currentRoomName}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // âŒ æ›´æ–°å…¨å±€ roomData å¹¶ç»˜åˆ¶åœ°å›¾
                roomData = data; 
                drawRoomMap(); 

                // æ›´æ–° roomDimensions å¹¶è®¾ç½®å®¹å™¨å¤§å°
                roomDimensions = { width: data.width, height: data.height };
                document.getElementById("room").style.width = roomDimensions.width + 'px';
                document.getElementById("room").style.height = roomDimensions.height + 'px';
                canvas.width = roomDimensions.width;
                canvas.height = roomDimensions.height;
                document.getElementById("room-container").style.width = roomDimensions.width + 'px';
                document.getElementById("room-container").style.height = roomDimensions.height + 'px';

                // æ¸…ç©ºå¹¶é‡æ–°æ¸²æŸ“è§’è‰²
                const roomDiv = document.getElementById("room");
                roomDiv.innerHTML = ""; // æ¸…ç©ºæ‰€æœ‰è§’è‰²
                data.roles.forEach(role => {
                    if (role.name.toLowerCase() === 'user') {
                        // åˆå§‹åŒ– userPosition å’Œ HTML DIV for 'user'
                        userPosition = { x: role.x, y: role.y };
                        document.getElementById("userPosition").innerText = 
                            `(${userPosition.x}, ${userPosition.y}) å·²è®¾ç½®`;
                        updateUserButtons(true);
                        addUserToRoom(); // é‡æ–°æ·»åŠ ç”¨æˆ·è§’è‰² DIV
                    } else {
                        addRoleToRoom(role);
                    }
                });
                
                document.getElementById("roleInfo").style.display = "none";
            } catch (error) {
                console.error("åŠ è½½æˆ¿é—´å¤±è´¥:", error);
                alert(`åŠ è½½æˆ¿é—´ ${currentRoomName} å¤±è´¥ã€‚è¯·ç¡®ä¿æœåŠ¡å™¨è¿è¡Œæ­£å¸¸ã€‚`);
            }
        }


        async function clearRoom() {
            if (!confirm(`ç¡®å®šè¦æ¸…ç©ºæˆ¿é—´ ${currentRoomName} çš„æ‰€æœ‰è§’è‰²å—ï¼Ÿè¿™ä¼šç§»é™¤æ‰€æœ‰ AI è§’è‰²å’Œç”¨æˆ·è§’è‰²ã€‚`)) {
                return;
            }
            try {
                const response = await fetch(`/api/room/${currentRoomName}/clear`, { method: 'POST' });
                if (response.ok) {
                    alert('æˆ¿é—´å·²æ¸…ç©ºï¼');
                    userPosition = null;
                    updateUserButtons(false);
                    loadRoom(); // é‡æ–°åŠ è½½ç©ºæˆ¿é—´
                } else {
                    alert('æ¸…ç©ºæˆ¿é—´å¤±è´¥ã€‚');
                }
            } catch (error) {
                console.error("æ¸…ç©ºæˆ¿é—´å¤±è´¥:", error);
            }
        }
        
        function addRole() {
            const roleName = prompt("è¯·è¾“å…¥æ–° AI è§’è‰²åç§° (ä¾‹å¦‚: å¦»å­, å„¿å­, æ™ºèƒ½ç®¡å®¶):");
            if (roleName) {
                // é»˜è®¤ä½ç½®è®¾ç½®åœ¨ç”¨æˆ·ä½ç½®é™„è¿‘ (ä¸­å¿ƒç‚¹ - 30)
                const x = userPosition ? userPosition.x + 80 : 100;
                const y = userPosition ? userPosition.y : 100;
                
                fetch(`/api/room/${currentRoomName}/role`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: roleName, x: x, y: y, avatar: "ğŸ¤–" })
                })
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    throw new Error('æ–°å¢è§’è‰²å¤±è´¥');
                })
                .then(data => {
                    console.log('æ–°å¢è§’è‰²æˆåŠŸ:', data);
                    // SocketIO ä¼šè§¦å‘ room_update
                })
                .catch(error => {
                    alert('æ–°å¢è§’è‰²å¤±è´¥: ' + error.message);
                });
            }
        }

        function updateRolePosition(role_name, x = userPosition.x, y = userPosition.y) {
            const targetX = Math.round(x);
            const targetY = Math.round(y);
            
            fetch(`/api/room/${currentRoomName}/role/${role_name}/position`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ x: targetX, y: targetY })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('æ›´æ–°ä½ç½®å¤±è´¥');
                }
            })
            .catch(error => {
                console.error("æ›´æ–°ä½ç½®å¤±è´¥:", error);
            });
        }

        function removeRole(role_name) {
            if (!confirm(`ç¡®å®šè¦ç§»é™¤è§’è‰² ${role_name} å—ï¼Ÿ`)) {
                return;
            }
            fetch(`/api/room/${currentRoomName}/role/${role_name}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (response.ok) {
                    alert(`è§’è‰² ${role_name} å·²ç§»é™¤ï¼`);
                    if (role_name.toLowerCase() === 'user') {
                        userPosition = null;
                        updateUserButtons(false);
                        document.getElementById("userPosition").innerText = "(N/A)";
                    }
                    loadRoom(); // é‡æ–°åŠ è½½æˆ¿é—´ä»¥æ›´æ–°åˆ—è¡¨
                } else {
                    alert('ç§»é™¤è§’è‰²å¤±è´¥ã€‚');
                }
            })
            .catch(error => {
                console.error("ç§»é™¤è§’è‰²å¤±è´¥:", error);
            });
        }
        
        async function sendMessage() {
            const messageInput = document.getElementById("chatMessage");
            const message = messageInput.value.trim();
            if (!message) return;

            // è·å–å½“å‰æˆ¿é—´ä¸­çš„ç¬¬ä¸€ä¸ª AI è§’è‰²ä½œä¸ºå¯¹è¯ç›®æ ‡
            const aiRoleElement = document.querySelector('.role.ai');
            if (!aiRoleElement) {
                alert("æˆ¿é—´ä¸­æ²¡æœ‰ AI è§’è‰²ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ã€‚");
                return;
            }
            const aiRoleName = aiRoleElement.dataset.roleName;

            appendMessage('user', message);
            messageInput.value = '';
            
            try {
                const response = await fetch(`/api/chat/${aiRoleName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_input: message, role_name: aiRoleName })
                });
                
                if (!response.ok) {
                    throw new Error(`API error! status: ${response.status}`);
                }

                // AI å›å¤é€šè¿‡ SocketIO çš„ chat_message äº‹ä»¶æ¥æ”¶
                console.log("æ¶ˆæ¯å‘é€æˆåŠŸï¼Œç­‰å¾… AI å›å¤...");

            } catch (error) {
                console.error("å‘é€æ¶ˆæ¯å¤±è´¥:", error);
                appendMessage('ç³»ç»Ÿ', `å‘ ${aiRoleName} å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`);
            }
        }
        
        async function toggleTimeAcceleration() {
            try {
                const response = await fetch('/api/time/toggle', { method: 'POST' });
                const data = await response.json();
                alert(data.message);
                // SocketIO ä¼šæ›´æ–°æ—¶é—´æ˜¾ç¤º
            } catch (error) {
                console.error("æ—¶é—´æ§åˆ¶å¤±è´¥:", error);
            }
        }


        // ------------------------------------
        // äº‹ä»¶ç›‘å¬å™¨ (æ•´åˆç¢°æ’æ£€æµ‹)
        // ------------------------------------
        
        // âŒ ä¿®æ”¹æˆ¿é—´ç‚¹å‡»äº‹ä»¶: æ·»åŠ ç¢°æ’æ£€æµ‹
        document.getElementById("room").addEventListener("click", function (e) {
            // é¿å…ç‚¹å‡»åˆ°è§’è‰²æ—¶è§¦å‘
            if (e.target.closest('.role')) {
                return;
            }

            const roomRect = this.getBoundingClientRect();
            const x = e.clientX - roomRect.left;
            const y = e.clientY - roomRect.top;

            // è¾¹ç•Œæ£€æŸ¥ (ä½¿ç”¨ä¸­å¿ƒç‚¹åæ ‡)
            const boundedX = Math.max(roleSize / 2, Math.min(x, roomDimensions.width - roleSize / 2));
            const boundedY = Math.max(roleSize / 2, Math.min(y, roomDimensions.height - roleSize / 2));
            
            // âŒ ç¢°æ’æ£€æµ‹
            if (checkCollision(boundedX, boundedY)) {
                console.log("ç‚¹å‡»ä½ç½®æœ‰ç¢°æ’ï¼Œæ— æ³•è®¾ç½®ç”¨æˆ·ä½ç½®ã€‚");
                alert("æ— æ³•å°†äººç‰©æ”¾ç½®åœ¨å¢™å£æˆ–å®¶å…·å†…éƒ¨ï¼");
                return; 
            }

            userPosition = { x: Math.round(boundedX), y: Math.round(boundedY) };
            document.getElementById("userPosition").innerText =
                `(${userPosition.x}, ${userPosition.y}) å·²è®¾ç½®`;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateUserButtons(true);

            // å®æ—¶æ˜¾ç¤ºç”¨æˆ·å›¾æ ‡
            addUserToRoom();
        });

        // ç‚¹å‡»å…¶ä»–åœ°æ–¹éšè—è§’è‰²ä¿¡æ¯
        document.addEventListener("click", (e) => {
            if (!e.target.closest("#roleInfo") && !e.target.closest(".role")) {
                document.getElementById("roleInfo").style.display = "none";
            }
        });

        // å›è½¦å‘é€æ¶ˆæ¯
        document.getElementById("chatMessage").addEventListener("keypress", function (e) {
            if (e.key === "Enter") {
                sendMessage();
            }
        });
    </script>
</body>

</html>